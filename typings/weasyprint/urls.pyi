"""
This type stub file was generated by pyright.
"""

import codecs
import contextlib
from gzip import GzipFile

"""Various utility functions and classes for URL management."""
UNICODE_SCHEME_RE = ...
BYTES_SCHEME_RE = ...
FILESYSTEM_ENCODING = ...
if codecs.lookup(FILESYSTEM_ENCODING).name == 'ascii':
    FILESYSTEM_ENCODING = ...
HTTP_HEADERS = ...
class StreamingGzipFile(GzipFile):
    def __init__(self, fileobj) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def seekable(self): # -> Literal[False]:
        ...
    


def iri_to_uri(url): # -> str:
    """Turn a Unicode IRI into an ASCII-only URI that conforms to RFC 3986."""
    ...

def path2url(path): # -> str:
    """Return file URL of `path`.

    Accepts 'str', 'bytes' or 'Path', returns 'str'.

    """
    ...

def url_is_absolute(url): # -> bool:
    """Return whether an URL (bytes or string) is absolute."""
    ...

def get_url_attribute(element, attr_name, base_url, allow_relative=...): # -> str | None:
    """Get the URI corresponding to the ``attr_name`` attribute.

    Return ``None`` if:

    * the attribute is empty or missing or,
    * the value is a relative URI but the document has no base URI and
      ``allow_relative`` is ``False``.

    Otherwise return an URI, absolute if possible.

    """
    ...

def url_join(base_url, url, allow_relative, context, context_args): # -> str | None:
    """Like urllib.urljoin, but warn if base_url is required but missing."""
    ...

def get_link_attribute(element, attr_name, base_url): # -> tuple[Literal['url'], tuple[str, str]] | tuple[Literal['url'], tuple[str, Any | str]] | None:
    """Get the URL value of an element attribute.

    Return ``('external', absolute_uri)``, or ``('internal',
    unquoted_fragment_id)``, or ``None``.

    """
    ...

def ensure_url(string): # -> str:
    """Get a ``scheme://path`` URL from ``string``.

    If ``string`` looks like an URL, return it unchanged. Otherwise assume a
    filename and convert it to a ``file://`` URL.

    """
    ...

def default_url_fetcher(url, timeout=..., ssl_context=..., http_headers=...): # -> dict[str, Any]:
    """Fetch an external resource such as an image or stylesheet.

    Another callable with the same signature can be given as the
    ``url_fetcher`` argument to :class:`HTML` or :class:`CSS`.
    (See :ref:`URL Fetchers`.)

    :param str url:
        The URL of the resource to fetch.
    :param int timeout:
        The number of seconds before HTTP requests are dropped.
    :param ssl.SSLContext ssl_context:
        An SSL context used for HTTP requests.
    :param dict http_headers:
        Additional HTTP headers used for HTTP requests.
    :raises: An exception indicating failure, e.g. :obj:`ValueError` on
        syntactically invalid URL.
    :returns: A :obj:`dict` with the following keys:

        * One of ``string`` (a :obj:`bytestring <bytes>`) or ``file_obj``
          (a :term:`file object`).
        * Optionally: ``mime_type``, a MIME type extracted e.g. from a
          *Content-Type* header. If not provided, the type is guessed from the
          file extension in the URL.
        * Optionally: ``encoding``, a character encoding extracted e.g. from a
          *charset* parameter in a *Content-Type* header
        * Optionally: ``redirected_url``, the actual URL of the resource
          if there were e.g. HTTP redirects.
        * Optionally: ``filename``, the filename of the resource. Usually
          derived from the *filename* parameter in a *Content-Disposition*
          header.
        * Optionally: ``path``, the path of the resource if it is stored on the
          local filesystem.

        If a ``file_obj`` key is given, it is the callerâ€™s responsibility
        to call ``file_obj.close()``. The default function used internally to
        fetch data in WeasyPrint tries to close the file object after
        retreiving; but if this URL fetcher is used elsewhere, the file object
        has to be closed manually.

    """
    ...

class URLFetchingError(IOError):
    """Some error happened when fetching an URL."""
    ...


@contextlib.contextmanager
def fetch(url_fetcher, url): # -> Generator[Any, Any, None]:
    """Call an url_fetcher, fill in optional data, and clean up."""
    ...

