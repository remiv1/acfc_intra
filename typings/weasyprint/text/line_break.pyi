"""
This type stub file was generated by pyright.
"""

"""Decide where to break text lines."""
def line_size(line, style): # -> tuple[Any, Any]:
    """Get logical width and height of the given ``line``.

    ``style`` is used to add letter spacing (if needed).

    """
    ...

def first_line_metrics(first_line, text, layout, resume_at, space_collapse, style, hyphenated=..., hyphenation_character=...): # -> tuple[Any, Any | Literal[0], Any, Any, Any, Any]:
    ...

class Layout:
    """Object holding PangoLayout-related cdata pointers."""
    def __init__(self, context, style, justification_spacing=..., max_width=...) -> None:
        ...
    
    def setup(self, context, style): # -> None:
        ...
    
    def get_first_line(self): # -> tuple[Any, Any | None]:
        ...
    
    def set_text(self, text, justify=...): # -> None:
        ...
    
    def set_tabs(self): # -> None:
        ...
    
    def deactivate(self): # -> None:
        ...
    
    def reactivate(self, style): # -> None:
        ...
    


def create_layout(text, style, context, max_width, justification_spacing): # -> Layout:
    """Return an opaque Pango layout with default Pango line-breaks."""
    ...

def split_first_line(text, style, context, max_width, justification_spacing, is_line_start=..., minimum=...):
    """Fit as much as possible in the available width for one line of text.

    Return ``(layout, length, resume_index, width, height, baseline)``.

    ``layout``: a pango Layout with the first line
    ``length``: length in UTF-8 bytes of the first line
    ``resume_index``: The number of UTF-8 bytes to skip for the next line.
                      May be ``None`` if the whole text fits in one line.
                      This may be greater than ``length`` in case of preserved
                      newline characters.
    ``width``: width in pixels of the first line
    ``height``: height in pixels of the first line
    ``baseline``: baseline in pixels of the first line

    """
    ...

def get_log_attrs(text, lang): # -> CData:
    ...

def get_next_break_point(log_attrs): # -> int | None:
    ...

def get_next_break_point_from_text(text, lang): # -> int | None:
    ...

def can_break_text(text, lang): # -> bool:
    ...

def get_next_word_boundaries(text, lang): # -> tuple[Any | int, int] | None:
    ...

def get_last_word_end(text, lang): # -> int | None:
    ...

