"""
This type stub file was generated by pyright.
"""

from .min_max import handle_min_max_width

"""Layout for inline-level boxes."""
def iter_line_boxes(context, box, position_y, bottom_space, skip_stack, containing_block, absolute_boxes, fixed_boxes, first_letter_style): # -> Generator[tuple[Any, Any], Any, None]:
    """Return an iterator of ``(line, resume_at)``.

    ``line`` is a laid-out LineBox with as much content as possible that
    fits in the available width.

    """
    ...

def get_next_linebox(context, linebox, position_y, bottom_space, skip_stack, containing_block, absolute_boxes, fixed_boxes, first_letter_style):
    """Return ``(line, resume_at)``."""
    ...

def skip_first_whitespace(box, skip_stack): # -> dict[Any | int, None] | dict[Any | int, Any] | Literal['continue'] | None:
    """Return ``skip_stack`` to start just after removable leading spaces.

    See https://www.w3.org/TR/CSS21/text.html#white-space-model

    """
    ...

def remove_last_whitespace(context, line): # -> None:
    """Remove in place space characters at the end of a line.

    This also reduces the width and position of the inline parents of the
    modified text.

    """
    ...

def first_letter_to_box(box, skip_stack, first_letter_style): # -> dict[Any, dict[Any, Any]] | dict[Any, Any] | None:
    """Create a box for the ::first-letter selector."""
    ...

def atomic_box(context, box, position_x, skip_stack, containing_block, absolute_boxes, fixed_boxes): # -> ReplacedBox:
    """Compute the width and the height of the atomic ``box``."""
    ...

def inline_block_box_layout(context, box, position_x, skip_stack, containing_block, absolute_boxes, fixed_boxes):
    ...

def inline_block_baseline(box):
    """Return the y position of the baseline for an inline block.

    Position is taken from the top of its margin box.

    https://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align

    """
    ...

@handle_min_max_width
def inline_block_width(box, context, containing_block): # -> None:
    ...

def split_inline_level(context, box, position_x, max_x, bottom_space, skip_stack, containing_block, absolute_boxes, fixed_boxes, line_placeholders, waiting_floats, line_children): # -> tuple[TextBox | Any | ReplacedBox | None, dict[Any, None] | Any | None, Any | Literal[False], Any | Literal['⺀'] | None, Any | Literal['⺀'] | None, dict[str, int] | Any]:
    """Fit as much content as possible from an inline-level box in a width.

    Return ``(new_box, resume_at, preserved_line_break, first_letter,
    last_letter)``. ``resume_at`` is ``None`` if all of the content
    fits. Otherwise it can be passed as a ``skip_stack`` parameter to resume
    where we left off.

    ``new_box`` is non-empty (unless the box is empty) and as big as possible
    while being narrower than ``available_width``, if possible (may overflow
    is no split is possible.)

    """
    ...

def split_inline_box(context, box, position_x, max_x, bottom_space, skip_stack, containing_block, absolute_boxes, fixed_boxes, line_placeholders, waiting_floats, line_children):
    """Same behavior as split_inline_level."""
    ...

def split_text_box(context, box, available_width, skip, is_line_start=...): # -> tuple[None, None, Literal[False]] | tuple[TextBox | None, Any, Any | Literal[False]]:
    """Keep as much text as possible from a TextBox in a limited width.

    Try not to overflow but always have some text in ``new_box``.

    Return ``(new_box, skip, preserved_line_break)``. ``skip`` is the number of
    UTF-8 bytes to skip form the start of the TextBox for the next line, or
    ``None`` if all of the text fits.

    Also break on preserved line breaks.

    """
    ...

def line_box_verticality(box): # -> tuple[Any, Any]:
    """Handle ``vertical-align`` within a :class:`LineBox`.

    Place all boxes vertically assuming that the baseline of ``box``
    is at `y = 0`.

    Return ``(max_y, min_y)``, the maximum and minimum vertical position
    of margin boxes.

    """
    ...

def translate_subtree(box, dy): # -> None:
    ...

def aligned_subtree_verticality(box, top_bottom_subtrees, baseline_y): # -> tuple[Any, Any]:
    ...

def inline_box_verticality(box, top_bottom_subtrees, baseline_y): # -> tuple[None, None] | tuple[Any | None, Any | None]:
    """Handle ``vertical-align`` within an :class:`InlineBox`.

    Place all boxes vertically assuming that the baseline of ``box``
    is at `y = baseline_y`.

    Return ``(max_y, min_y)``, the maximum and minimum vertical position
    of margin boxes.

    """
    ...

def text_align(context, line, available_width, last): # -> Literal[0]:
    """Return the line horizontal offset according to ``text-align``."""
    ...

def justify_line(context, line, extra_width): # -> None:
    ...

def count_expandable_spaces(box): # -> int:
    """Count expandable spaces (space and nbsp) for justification."""
    ...

def add_word_spacing(context, box, justification_spacing, x_advance):
    ...

def is_phantom_linebox(linebox): # -> bool:
    ...

def can_break_inside(box): # -> bool:
    ...

