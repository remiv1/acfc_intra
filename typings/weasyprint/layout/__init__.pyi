"""
This type stub file was generated by pyright.
"""

from collections import defaultdict
from functools import partial
from math import inf
from ..formatting_structure import boxes, build
from ..logger import PROGRESS_LOGGER
from .absolute import absolute_box_layout, absolute_layout
from .background import layout_backgrounds
from .block import block_level_layout
from .page import make_all_pages, make_margin_boxes

"""Transform a "before layout" box tree into an "after layout" tree.

Break boxes across lines and pages; determine the size and dimension of each
box fragement.

Boxes in the new tree have *used values* in their ``position_x``,
``position_y``, ``width`` and ``height`` attributes, amongst others.

See https://www.w3.org/TR/CSS21/cascade.html#used-value

"""
def initialize_page_maker(context, root_box): # -> None:
    """Initialize ``context.page_maker``.

    Collect the pagination's states required for page based counters.

    """
    ...

def layout_fixed_boxes(context, pages, containing_page): # -> Generator[Any, Any, None]:
    """Lay out and yield fixed boxes of ``pages`` on ``containing_page``."""
    ...

def layout_document(html, root_box, context, max_loops=...): # -> Generator[Any, Any, None]:
    """Lay out the whole document.

    This includes line breaks, page breaks, absolute size and position for all
    boxes. Page based counters might require multiple passes.

    :param root_box:
        Root of the box tree (formatting structure of the HTML). The page boxes
        are created from that tree, this structure is not lost during
        pagination.
    :returns:
        A list of laid out Page objects.

    """
    ...

class FakeList(list):
    """List in which you canâ€™t append objects."""
    def append(self, item): # -> None:
        ...
    


class LayoutContext:
    def __init__(self, style_for, get_image_from_uri, font_config, counter_style, target_collector) -> None:
        ...
    
    def overflows_page(self, bottom_space, position_y):
        ...
    
    @staticmethod
    def overflows(bottom, position_y):
        ...
    
    def create_block_formatting_context(self): # -> None:
        ...
    
    def finish_block_formatting_context(self, root_box): # -> None:
        ...
    
    def create_flex_formatting_context(self): # -> None:
        ...
    
    def finish_flex_formatting_context(self, root_box): # -> None:
        ...
    
    def get_string_set_for(self, page, name, keyword=...): # -> None:
        """Resolve value of string function."""
        ...
    
    def get_running_element_for(self, page, name, keyword=...): # -> None:
        """Resolve value of element function."""
        ...
    
    def get_string_or_element_for(self, store, page, name, keyword): # -> None:
        """Resolve value of string or element function.

        We'll have something like this that represents all assignments on a
        given page:

        {1: ['First Header'], 3: ['Second Header'],
         4: ['Third Header', '3.5th Header']}

        Value depends on current page.
        https://drafts.csswg.org/css-gcpm/#funcdef-string

        :param dict store:
            Dictionary where the resolved value is stored.
        :param page:
            Current page.
        :param str name:
            Name of the named string or running element.
        :param str keyword:
            Indicates which value of the named string or running element to
            use. Default is the first assignment on the current page else the
            most recent assignment.
        :returns:
            Text for string set, box for running element.

        """
        ...
    
    def layout_footnote(self, footnote): # -> Literal[False]:
        """Add a footnote to the layout for this page."""
        ...
    
    def unlayout_footnote(self, footnote): # -> None:
        """Remove a footnote from the layout and return it to the waitlist."""
        ...
    
    def report_footnote(self, footnote): # -> None:
        """Mark a footnote as being moved to the next page."""
        ...
    


