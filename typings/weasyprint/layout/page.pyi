"""
This type stub file was generated by pyright.
"""

from .min_max import handle_min_max_height, handle_min_max_width

"""Layout for pages and CSS3 margin boxes."""
PageType = ...
class OrientedBox:
    @property
    def sugar(self):
        ...
    
    @property
    def outer(self):
        ...
    
    @outer.setter
    def outer(self, new_outer_width): # -> None:
        ...
    
    @property
    def outer_min_content_size(self):
        ...
    
    @property
    def outer_max_content_size(self):
        ...
    


class VerticalBox(OrientedBox):
    def __init__(self, context, box) -> None:
        ...
    
    def restore_box_attributes(self): # -> None:
        ...
    
    @property
    def min_content_size(self): # -> Literal[0]:
        ...
    
    @property
    def max_content_size(self): # -> float:
        ...
    


class HorizontalBox(OrientedBox):
    def __init__(self, context, box) -> None:
        ...
    
    def restore_box_attributes(self): # -> None:
        ...
    
    @property
    def min_content_size(self): # -> float | int:
        ...
    
    @property
    def max_content_size(self): # -> float | int:
        ...
    


def compute_fixed_dimension(context, box, outer, vertical, top_or_left): # -> None:
    """Compute and set a margin box fixed dimension on ``box``.

    Described in: https://drafts.csswg.org/css-page-3/#margin-constraints

    :param box:
        The margin box to work on
    :param outer:
        The target outer dimension (value of a page margin)
    :param vertical:
        True to set height, margin-top and margin-bottom; False for width,
        margin-left and margin-right
    :param top_or_left:
        True if the margin box in if the top half (for vertical==True) or
        left half (for vertical==False) of the page.
        This determines which margin should be 'auto' if the values are
        over-constrained. (Rule 3 of the algorithm.)
    """
    ...

def compute_variable_dimension(context, side_boxes, vertical, available_size): # -> None:
    """Compute and set a margin box fixed dimension on ``box``

    Described in: https://drafts.csswg.org/css-page-3/#margin-dimension

    :param side_boxes:
        Three boxes on a same side (as opposed to a corner).
        A list of:
        - A @*-left or @*-top margin box
        - A @*-center or @*-middle margin box
        - A @*-right or @*-bottom margin box
    :param vertical:
        ``True`` to set height, margin-top and margin-bottom;
        ``False`` for width, margin-left and margin-right.
    :param available_size:
        The distance between the page box’s left right border edges

    """
    ...

def make_margin_boxes(context, page, state): # -> Generator[Any, Any, None]:
    """Yield laid-out margin boxes for this page.

    ``state`` is the actual, up-to-date page-state from
    ``context.page_maker[context.current_page]``.

    """
    ...

def margin_box_content_layout(context, page, box):
    """Layout a margin box’s content once the box has dimensions."""
    ...

def page_width_or_height(box, containing_block_size): # -> None:
    """Take a :class:`OrientedBox` object and set either width, margin-left
    and margin-right; or height, margin-top and margin-bottom.

    "The width and horizontal margins of the page box are then calculated
     exactly as for a non-replaced block element in normal flow. The height
     and vertical margins of the page box are calculated analogously (instead
     of using the block height formulas). In both cases if the values are
     over-constrained, instead of ignoring any margins, the containing block
     is resized to coincide with the margin edges of the page box."

    https://drafts.csswg.org/css-page-3/#page-box-page-rule
    https://www.w3.org/TR/CSS21/visudet.html#blockwidth

    """
    ...

@handle_min_max_width
def page_width(box, context, containing_block_width): # -> None:
    ...

@handle_min_max_height
def page_height(box, context, containing_block_height): # -> None:
    ...

def make_page(context, root_box, page_type, resume_at, page_number, page_state):
    """Take just enough content from the beginning to fill one page.

    Return ``(page, finished)``. ``page`` is a laid out PageBox object
    and ``resume_at`` indicates where in the document to start the next page,
    or is ``None`` if this was the last page.

    :param int page_number:
        Page number, starts at 1 for the first page.
    :param resume_at:
        As returned by ``make_page()`` for the previous page, or ``None`` for
        the first page.

    """
    ...

def set_page_type_computed_styles(page_type, html, style_for): # -> None:
    """Set style for page types and pseudo-types matching ``page_type``."""
    ...

def remake_page(index, page_groups, context, root_box, html): # -> tuple[Any, Any]:
    """Return one laid out page without margin boxes.

    Start with the initial values from ``context.page_maker[index]``.
    The resulting values / initial values for the next page are stored in
    the ``page_maker``.

    As the function's name suggests: the plan is not to make all pages
    repeatedly when a missing counter was resolved, but rather re-make the
    single page where the ``content_changed`` happened.

    """
    ...

def make_all_pages(context, root_box, html, pages): # -> Generator[Any, Any, None]:
    """Return a list of laid out pages without margin boxes.

    Re-make pages only if necessary.

    """
    ...

