"""
This type stub file was generated by pyright.
"""

"""Classes for all types of boxes in the CSS formatting structure / box model.

See https://www.w3.org/TR/CSS21/visuren.html

Names are the same as in CSS 2.1 with the exception of ``TextBox``. In
WeasyPrint, any text is in a ``TextBox``. What CSS calls anonymous inline boxes
are text boxes but not all text boxes are anonymous inline boxes.

See https://www.w3.org/TR/CSS21/visuren.html#anonymous

Abstract classes, should not be instantiated:

* Box
* BlockLevelBox
* InlineLevelBox
* BlockContainerBox
* ReplacedBox
* ParentBox
* AtomicInlineLevelBox

Concrete classes:

* PageBox
* BlockBox
* InlineBox
* InlineBlockBox
* BlockReplacedBox
* InlineReplacedBox
* TextBox
* LineBox
* Various table-related Box subclasses

All concrete box classes whose name contains "Inline" or "Block" have one of
the following "outside" behavior:

* Block-level (inherits from :class:`BlockLevelBox`)
* Inline-level (inherits from :class:`InlineLevelBox`)

and one of the following "inside" behavior:

* Block container (inherits from :class:`BlockContainerBox`)
* Inline content (InlineBox and :class:`TextBox`)
* Replaced content (inherits from :class:`ReplacedBox`)

… with various combinasions of both.

See respective docstrings for details.

"""
class Box:
    """Abstract base class for all boxes."""
    proper_table_child = ...
    internal_table_or_caption = ...
    tabular_container = ...
    leading_collapsible_space = ...
    trailing_collapsible_space = ...
    is_table_wrapper = ...
    is_flex_item = ...
    is_grid_item = ...
    is_for_root_element = ...
    is_column = ...
    is_leader = ...
    is_outside_marker = ...
    transformation_matrix = ...
    bookmark_label = ...
    string_set = ...
    footnote = ...
    cached_counter_values = ...
    missing_link = ...
    link_annotation = ...
    force_fragmentation = ...
    def all_children(self): # -> list[Any]:
        ...
    
    def descendants(self, placeholders=...): # -> Generator[Self | Any, Any, None]:
        """A flat generator for a box, its children and descendants."""
        ...
    
    def __init__(self, element_tag, style, element) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @classmethod
    def anonymous_from(cls, parent, *args, **kwargs): # -> Self:
        """Return an anonymous box that inherits from ``parent``."""
        ...
    
    def copy(self): # -> Self:
        """Return shallow copy of the box."""
        ...
    
    def deepcopy(self): # -> Self:
        """Return a copy of the box with recursive copies of its children."""
        ...
    
    def translate(self, dx=..., dy=..., ignore_floats=...): # -> None:
        """Change the box’s position.

        Also update the children’s positions accordingly.

        """
        ...
    
    def padding_width(self):
        """Width of the padding box."""
        ...
    
    def padding_height(self):
        """Height of the padding box."""
        ...
    
    def border_width(self):
        """Width of the border box."""
        ...
    
    def border_height(self):
        """Height of the border box."""
        ...
    
    def margin_width(self):
        """Width of the margin box (aka. outer box)."""
        ...
    
    def margin_height(self):
        """Height of the margin box (aka. outer box)."""
        ...
    
    def content_box_x(self):
        """Absolute horizontal position of the content box."""
        ...
    
    def content_box_y(self):
        """Absolute vertical position of the content box."""
        ...
    
    def padding_box_x(self):
        """Absolute horizontal position of the padding box."""
        ...
    
    def padding_box_y(self):
        """Absolute vertical position of the padding box."""
        ...
    
    def border_box_x(self):
        """Absolute horizontal position of the border box."""
        ...
    
    def border_box_y(self):
        """Absolute vertical position of the border box."""
        ...
    
    def hit_area(self): # -> tuple[Any, Any, Any, Any]:
        """Return the (x, y, w, h) rectangle where the box is clickable."""
        ...
    
    def rounded_box(self, bt, br, bb, bl): # -> tuple[Any, Any, Any, Any, tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
        """Position, size and radii of a box inside the outer border box.

        bt, br, bb, and bl are distances from the outer border box,
        defining a rectangle to be rounded.

        """
        ...
    
    def rounded_box_ratio(self, ratio): # -> tuple[Any, Any, Any, Any, tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
        ...
    
    def rounded_padding_box(self): # -> tuple[Any, Any, Any, Any, tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
        """Return the position, size and radii of the rounded padding box."""
        ...
    
    def rounded_border_box(self): # -> tuple[Any, Any, Any, Any, tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
        """Return the position, size and radii of the rounded border box."""
        ...
    
    def rounded_content_box(self): # -> tuple[Any, Any, Any, Any, tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
        """Return the position, size and radii of the rounded content box."""
        ...
    
    def is_floated(self): # -> bool:
        """Return whether this box is floated."""
        ...
    
    def is_footnote(self):
        """Return whether this box is a footnote."""
        ...
    
    def is_absolutely_positioned(self): # -> bool:
        """Return whether this box is in the absolute positioning scheme."""
        ...
    
    def is_running(self):
        """Return whether this box is a running element."""
        ...
    
    def is_in_normal_flow(self): # -> bool:
        """Return whether this box is in normal flow."""
        ...
    
    def is_monolithic(self): # -> Literal[True]:
        """Return whether this box is monolithic."""
        ...
    
    def establishes_formatting_context(self): # -> bool:
        """Return whether this box establishes a block formatting context."""
        ...
    
    def page_values(self): # -> tuple[Any, Any]:
        """Return start and end page values."""
        ...
    
    def is_attachment(self): # -> bool:
        """Return whether this link should be stored as a PDF attachment."""
        ...
    
    def is_input(self): # -> bool:
        """Return whether this box is a form input."""
        ...
    
    def is_form(self): # -> Literal[False]:
        """Return whether this box is a form element."""
        ...
    


class ParentBox(Box):
    """A box that has children."""
    def __init__(self, element_tag, style, element, children) -> None:
        ...
    
    def remove_decoration(self, start, end): # -> None:
        ...
    
    def copy_with_children(self, new_children): # -> Self:
        """Create a new equivalent box with given ``new_children``."""
        ...
    
    def deepcopy(self): # -> Self:
        ...
    
    def get_wrapped_table(self): # -> TableBox:
        """Get the table wrapped by the box."""
        ...
    
    def page_values(self): # -> tuple[Any, Any]:
        ...
    


class BlockLevelBox(Box):
    """A box that participates in an block formatting context.

    An element with a ``display`` value of ``block``, ``list-item`` or
    ``table`` generates a block-level box.

    """
    clearance = ...


class BlockContainerBox(ParentBox):
    """A box that contains only block-level boxes or only line boxes.

    A box that either contains only block-level boxes or establishes an inline
    formatting context and thus contains only line boxes.

    A non-replaced element with a ``display`` value of ``block``,
    ``list-item``, ``inline-block`` or 'table-cell' generates a block container
    box.

    """
    ...


class BlockBox(BlockContainerBox, BlockLevelBox):
    """A block-level box that is also a block container.

    A non-replaced element with a ``display`` value of ``block``, ``list-item``
    generates a block box.

    """
    ...


class LineBox(ParentBox):
    """A box that represents a line in an inline formatting context.

    Can only contain inline-level boxes.

    In early stages of building the box tree a single line box contains many
    consecutive inline boxes. Later, during layout phase, each line boxes will
    be split into multiple line boxes, one for each actual line.

    """
    text_overflow = ...
    block_ellipsis = ...
    @classmethod
    def anonymous_from(cls, parent, *args, **kwargs): # -> Self:
        ...
    


class InlineLevelBox(Box):
    """A box that participates in an inline formatting context.

    An inline-level box that is not an inline box is said to be "atomic". Such
    boxes are inline blocks, replaced elements and inline tables.

    An element with a ``display`` value of ``inline``, ``inline-table``, or
    ``inline-block`` generates an inline-level box.

    """
    def remove_decoration(self, start, end): # -> None:
        ...
    


class InlineBox(InlineLevelBox, ParentBox):
    """An inline box with inline children.

    A box that participates in an inline formatting context and whose content
    also participates in that inline formatting context.

    A non-replaced element with a ``display`` value of ``inline`` generates an
    inline box.

    """
    def hit_area(self): # -> tuple[Any, Any, Any, Any]:
        """Return the (x, y, w, h) rectangle where the box is clickable."""
        ...
    


class TextBox(InlineLevelBox):
    """A box that contains only text and has no box children.

    Any text in the document ends up in a text box. What CSS calls "anonymous
    inline boxes" are also text boxes.

    """
    justification_spacing = ...
    def __init__(self, element_tag, style, element, text) -> None:
        ...
    
    def copy_with_text(self, text): # -> Self:
        """Return a new TextBox identical to this one except for the text."""
        ...
    


class AtomicInlineLevelBox(InlineLevelBox):
    """An atomic box in an inline formatting context.

    This inline-level box cannot be split for line breaks.

    """
    ...


class InlineBlockBox(AtomicInlineLevelBox, BlockContainerBox):
    """A box that is both inline-level and a block container.

    It behaves as inline on the outside and as a block on the inside.

    A non-replaced element with a 'display' value of 'inline-block' generates
    an inline-block box.

    """
    ...


class ReplacedBox(Box):
    """A box whose content is replaced.

    For example, ``<img>`` are replaced: their content is rendered externally
    and is opaque from CSS’s point of view.

    """
    def __init__(self, element_tag, style, element, replacement) -> None:
        ...
    


class BlockReplacedBox(ReplacedBox, BlockLevelBox):
    """A box that is both replaced and block-level.

    A replaced element with a ``display`` value of ``block``, ``liste-item`` or
    ``table`` generates a block-level replaced box.

    """
    ...


class InlineReplacedBox(ReplacedBox, AtomicInlineLevelBox):
    """A box that is both replaced and inline-level.

    A replaced element with a ``display`` value of ``inline``,
    ``inline-table``, or ``inline-block`` generates an inline-level replaced
    box.

    """
    ...


class TableBox(BlockLevelBox, ParentBox):
    """Box for elements with ``display: table``"""
    tabular_container = ...
    def all_children(self): # -> chain[Any]:
        ...
    
    def translate(self, dx=..., dy=..., ignore_floats=...): # -> None:
        ...
    
    def page_values(self): # -> tuple[Any, Any]:
        ...
    


class InlineTableBox(TableBox):
    """Box for elements with ``display: inline-table``"""
    ...


class TableRowGroupBox(ParentBox):
    """Box for elements with ``display: table-row-group``"""
    proper_table_child = ...
    internal_table_or_caption = ...
    tabular_container = ...
    proper_parents = ...
    is_header = ...
    is_footer = ...


class TableRowBox(ParentBox):
    """Box for elements with ``display: table-row``"""
    proper_table_child = ...
    internal_table_or_caption = ...
    tabular_container = ...
    proper_parents = ...


class TableColumnGroupBox(ParentBox):
    """Box for elements with ``display: table-column-group``"""
    proper_table_child = ...
    internal_table_or_caption = ...
    proper_parents = ...
    margin_top = ...
    margin_bottom = ...
    margin_left = ...
    margin_right = ...
    padding_top = ...
    padding_bottom = ...
    padding_left = ...
    padding_right = ...
    def get_cells(self): # -> list[Any]:
        """Return cells that originate in the group's columns."""
        ...
    
    @property
    def span(self): # -> int:
        ...
    


class TableColumnBox(ParentBox):
    """Box for elements with ``display: table-column``"""
    proper_table_child = ...
    internal_table_or_caption = ...
    proper_parents = ...
    margin_top = ...
    margin_bottom = ...
    margin_left = ...
    margin_right = ...
    padding_top = ...
    padding_bottom = ...
    padding_left = ...
    padding_right = ...
    def get_cells(self):
        """Return cells that originate in the column.

        Is set on instances.

        """
        ...
    
    @property
    def span(self): # -> int:
        ...
    


class TableCellBox(BlockContainerBox):
    """Box for elements with ``display: table-cell``"""
    internal_table_or_caption = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class TableCaptionBox(BlockBox):
    """Box for elements with ``display: table-caption``"""
    proper_table_child = ...
    internal_table_or_caption = ...
    proper_parents = ...


class PageBox(ParentBox):
    """Box for a page.

    Initially the whole document will be in the box for the root element.
    During layout a new page box is created after every page break.

    """
    def __init__(self, page_type, style) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def bleed(self): # -> dict[str, Any]:
        ...
    
    @property
    def bleed_area(self): # -> tuple[Any, Any, Any, Any]:
        ...
    


class MarginBox(BlockContainerBox):
    """Box in page margins, as defined in CSS3 Paged Media"""
    def __init__(self, at_keyword, style) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class FootnoteAreaBox(BlockBox):
    """Box displaying footnotes, as defined in GCPM."""
    def __init__(self, page, style) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class FlexContainerBox(ParentBox):
    """A box that contains only flex-items."""
    ...


class FlexBox(FlexContainerBox, BlockLevelBox):
    """A box that is both block-level and a flex container.

    It behaves as block on the outside and as a flex container on the inside.

    """
    ...


class InlineFlexBox(FlexContainerBox, InlineLevelBox):
    """A box that is both inline-level and a flex container.

    It behaves as inline on the outside and as a flex container on the inside.

    """
    ...


class GridContainerBox(ParentBox):
    """A box that contains only grid-items."""
    ...


class GridBox(GridContainerBox, BlockLevelBox):
    """A box that is both block-level and a grid container.

    It behaves as block on the outside and as a grid container on the inside.

    """
    ...


class InlineGridBox(GridContainerBox, InlineLevelBox):
    """A box that is both inline-level and a grid container.

    It behaves as inline on the outside and as a grid container on the inside.

    """
    ...


