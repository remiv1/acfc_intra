"""
This type stub file was generated by pyright.
"""

"""Turn an element tree with style into a "before layout" box tree.

This includes creating anonymous boxes and processing whitespace as necessary.

"""
BOX_TYPE_FROM_DISPLAY = ...
ASCII_TO_WIDE = ...
LINE_FEED_RE = ...
TAB_RE = ...
SPACE_RE = ...
def create_anonymous_boxes(box): # -> BlockContainerBox:
    """Create anonymous boxes in box descendants according to layout rules."""
    ...

def build_formatting_structure(element_tree, style_for, get_image_from_uri, base_url, target_collector, counter_style, footnotes): # -> BlockContainerBox:
    """Build a formatting structure (box tree) from an element tree."""
    ...

def make_box(element_tag, style, content, element):
    ...

def element_to_box(element, style_for, get_image_from_uri, base_url, target_collector, counter_style, footnotes, state=...): # -> list[Any]:
    """Convert an element and its children into a box with children.

    Return a list of boxes. Most of the time the list will have one item but
    may have zero or more than one.

    Eg.::

        <p>Some <em>emphasised</em> text.</p>

    gives (not actual syntax)::

        BlockBox[
            TextBox['Some '],
            InlineBox[
                TextBox['emphasised'],
            ],
            TextBox[' text.'],
        ]

    ``TextBox``es are anonymous inline boxes:
    See https://www.w3.org/TR/CSS21/visuren.html#anonymous

    """
    ...

def before_after_to_box(element, pseudo_type, state, style_for, get_image_from_uri, target_collector, counter_style): # -> list[Any]:
    """Return the boxes for ::before or ::after pseudo-element."""
    ...

def marker_to_box(element, state, parent_style, style_for, get_image_from_uri, target_collector, counter_style): # -> Generator[BlockBox | InlineBox, Any, None]:
    """Yield the box for ::marker pseudo-element if there is one.

    https://drafts.csswg.org/css-lists-3/#marker-pseudo

    """
    ...

def compute_content_list(content_list, parent_box, counter_values, css_token, parse_again, target_collector, counter_style, get_image_from_uri=..., quote_depth=..., quote_style=..., lang=..., context=..., page=..., element=...):
    """Compute and return the boxes corresponding to the ``content_list``.

    ``parse_again`` is called to compute the ``content_list`` again when
    ``target_collector.lookup_target()`` detected a pending target.

    ``build_formatting_structure`` calls
    ``target_collector.check_pending_targets()`` after the first pass to do
    required reparsing.

    """
    ...

def content_to_boxes(style, parent_box, quote_depth, counter_values, get_image_from_uri, target_collector, counter_style, context=..., page=...): # -> list[Any]:
    """Take the value of a ``content`` property and return boxes."""
    ...

def compute_string_set(element, box, string_name, content_list, counter_values, target_collector, counter_style): # -> None:
    """Parse the content-list value of ``string_name`` for ``string-set``."""
    ...

def compute_bookmark_label(element, box, content_list, counter_values, target_collector, counter_style): # -> None:
    """Parses the content-list value for ``bookmark-label``."""
    ...

def set_content_lists(element, box, style, counter_values, target_collector, counter_style): # -> None:
    """Set the content-lists values.

    These content-lists are used in GCPM properties like ``string-set`` and
    ``bookmark-label``.

    """
    ...

def update_counters(state, style): # -> None:
    """Handle the ``counter-*`` properties."""
    ...

def is_whitespace(box, _has_non_whitespace=...): # -> bool:
    """Return True if ``box`` is a TextBox with only whitespace."""
    ...

def wrap_improper(box, children, wrapper_type, test=...): # -> Generator[BlockBox | InlineBlockBox | InlineBox | TableRowBox | TableRowGroupBox | TableColumnBox | TableColumnGroupBox | Any, Any, None]:
    """Wrap consecutive children that do not pass ``test`` in a ``wrapper_type`` box.

    ``test`` defaults to children being of the same type as ``wrapper_type``.

    """
    ...

def anonymous_table_boxes(box): # -> ParentBox | InlineBox | TableRowBox | TableRowGroupBox | TableColumnBox | TableColumnGroupBox:
    """Remove and add boxes according to the table model.

    Take and return a ``Box`` object.

    See https://www.w3.org/TR/CSS21/tables.html#anonymous-boxes

    """
    ...

def table_boxes_children(box, children): # -> InlineBox | TableRowBox | TableRowGroupBox | TableColumnBox | TableColumnGroupBox:
    """Internal implementation of anonymous_table_boxes()."""
    ...

def wrap_table(box, children):
    """Take a table box and return it in its table wrapper box.

    Also re-order children and assign grid positions to each column and cell.

    Because of colspan/rowspan works, grid_y is implicitly the index of a row,
    but grid_x is an explicit attribute on cells, columns and column group.

    https://www.w3.org/TR/CSS21/tables.html#model
    https://www.w3.org/TR/CSS21/tables.html#table-layout

    """
    ...

def blockify(box, layout): # -> BlockBox | BlockReplacedBox:
    """Turn an inline box into a block box."""
    ...

def flex_boxes(box): # -> ParentBox:
    """Remove and add boxes according to the flex model.

    Take and return a ``Box`` object.

    See https://www.w3.org/TR/css-flexbox-1/#flex-items

    """
    ...

def flex_children(box, children): # -> list[Any]:
    ...

def grid_boxes(box): # -> ParentBox:
    """Remove and add boxes according to the grid model.

    Take and return a ``Box`` object.

    See https://drafts.csswg.org/css-grid-2/#grid-item

    """
    ...

def grid_children(box, children): # -> list[Any]:
    ...

def process_whitespace(box, following_collapsible_space=...): # -> bool:
    """First part of "The 'white-space' processing model".

    See https://www.w3.org/TR/CSS21/text.html#white-space-model
    https://drafts.csswg.org/css-text-3/#white-space-rules

    """
    ...

def process_text_transform(box): # -> None:
    ...

def capitalize(text): # -> Literal['']:
    """Capitalize words according to CSSâ€™s "text-transform: capitalize"."""
    ...

def inline_in_block(box): # -> BlockContainerBox:
    """Build the structure of lines inside blocks and return a new box tree.

    Consecutive inline-level boxes in a block container box are wrapped into a
    line box, itself wrapped into an anonymous block box.

    This line box will be broken into multiple lines later.

    This is the first case in
    https://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level

    Eg.::

        BlockBox[
            TextBox['Some '],
            InlineBox[TextBox['text']],
            BlockBox[
                TextBox['More text'],
            ]
        ]

    is turned into::

        BlockBox[
            AnonymousBlockBox[
                LineBox[
                    TextBox['Some '],
                    InlineBox[TextBox['text']],
                ]
            ]
            BlockBox[
                LineBox[
                    TextBox['More text'],
                ]
            ]
        ]

    """
    ...

def block_in_inline(box):
    """Build the structure of blocks inside lines.

    Inline boxes containing block-level boxes will be broken in two
    boxes on each side on consecutive block-level boxes, each side wrapped
    in an anonymous block-level box.

    This is the second case in
    https://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level

    Eg. if this is given::

        BlockBox[
            LineBox[
                InlineBox[
                    TextBox['Hello.'],
                ],
                InlineBox[
                    TextBox['Some '],
                    InlineBox[
                        TextBox['text']
                        BlockBox[LineBox[TextBox['More text']]],
                        BlockBox[LineBox[TextBox['More text again']]],
                    ],
                    BlockBox[LineBox[TextBox['And again.']]],
                ]
            ]
        ]

    this is returned::

        BlockBox[
            AnonymousBlockBox[
                LineBox[
                    InlineBox[
                        TextBox['Hello.'],
                    ],
                    InlineBox[
                        TextBox['Some '],
                        InlineBox[TextBox['text']],
                    ]
                ]
            ],
            BlockBox[LineBox[TextBox['More text']]],
            BlockBox[LineBox[TextBox['More text again']]],
            AnonymousBlockBox[
                LineBox[
                    InlineBox[
                    ]
                ]
            ],
            BlockBox[LineBox[TextBox['And again.']]],
            AnonymousBlockBox[
                LineBox[
                    InlineBox[
                    ]
                ]
            ],
        ]

    """
    ...

def set_viewport_overflow(root_box):
    """
    Set a ``viewport_overflow`` attribute on the box for the root element.

    Like backgrounds, ``overflow`` on the root element must be propagated
    to the viewport.

    See https://www.w3.org/TR/CSS21/visufx.html#overflow
    """
    ...

def box_text(box): # -> LiteralString | Literal['']:
    ...

def extract_text(text_part, box): # -> LiteralString | Literal[''] | None:
    ...

