"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod

"""Utils for CSS properties."""
ANGLE_TO_RADIANS = ...
LENGTHS_TO_PIXELS = ...
RESOLUTION_TO_DPPX = ...
LENGTH_UNITS = ...
ZERO_PERCENT = ...
FIFTY_PERCENT = ...
HUNDRED_PERCENT = ...
BACKGROUND_POSITION_PERCENTAGES = ...
DIRECTION_KEYWORDS = ...
ATTR_FALLBACKS = ...
class InvalidValues(ValueError):
    """Invalid or unsupported values for a known CSS property."""
    ...


class CenterKeywordFakeToken:
    type = ...
    lower_value = ...
    unit = ...


class Pending(ABC):
    """Abstract class representing property value with pending validation."""
    def __init__(self, tokens, name) -> None:
        ...
    
    @abstractmethod
    def validate(self, tokens, wanted_key):
        """Get validated value for wanted key."""
        ...
    
    def solve(self, tokens, wanted_key):
        """Get validated value or raise error."""
        ...
    


def split_on_comma(tokens): # -> tuple[Any, ...]:
    """Split a list of tokens on commas, ie ``LiteralToken(',')``.

    Only "top-level" comma tokens are splitting points, not commas inside a
    function or blocks.

    """
    ...

def split_on_optional_comma(tokens): # -> list[Any] | None:
    """Split a list of tokens on optional commas, ie ``LiteralToken(',')``."""
    ...

def remove_whitespace(tokens): # -> tuple[Any, ...]:
    """Remove any top-level whitespace and comments in a token list."""
    ...

def safe_urljoin(base_url, url): # -> str:
    ...

def comma_separated_list(function): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], tuple[Any, ...] | None]:
    """Decorator for validators that accept a comma separated list."""
    ...

def get_keyword(token): # -> None:
    """If ``token`` is a keyword, return its lowercase name.

    Otherwise return ``None``.

    """
    ...

def get_custom_ident(token): # -> None:
    """If ``token`` is a keyword, return its name.

    Otherwise return ``None``.

    """
    ...

def get_single_keyword(tokens): # -> None:
    """If ``values`` is a 1-element list of keywords, return its name.

    Otherwise return ``None``.

    """
    ...

def single_keyword(function): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any | None]:
    """Decorator for validators that only accept a single keyword."""
    ...

def single_token(function): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any | None]:
    """Decorator for validators that only accept a single token."""
    ...

def parse_linear_gradient_parameters(arguments): # -> tuple[tuple[str, Any], Any] | tuple[Any, Any] | tuple[tuple[str, float], Any]:
    ...

def parse_2d_position(tokens): # -> tuple[Dimension, Dimension] | None:
    """Common syntax of background-position and transform-origin."""
    ...

def parse_position(tokens): # -> tuple[Literal['left'], Dimension, Literal['top'], Dimension] | tuple[Literal['left', 'right'], Dimension, Literal['top', 'bottom'], Dimension] | tuple[Literal['left'], Dimension, Literal['top', 'bottom'], Dimension] | tuple[Literal['left', 'right'], Dimension, Literal['top'], Dimension] | None:
    """Parse background-position and object-position.

    See https://drafts.csswg.org/css-backgrounds-3/#the-background-position
    https://drafts.csswg.org/css-images-3/#propdef-object-position

    """
    ...

def parse_radial_gradient_parameters(arguments): # -> tuple[Literal['circle', 'ellipse'], tuple[Literal['keyword'], Literal['closest-corner', 'farthest-corner', 'closest-side', 'farthest-side']] | tuple[Literal['keyword'], Literal['farthest-corner']] | tuple[Literal['explicit'], tuple[Dimension, Dimension]] | tuple[Literal['explicit'], tuple[Dimension | None, Dimension | None]], tuple[Literal['left'], Dimension, Literal['top'], Dimension] | tuple[Literal['left', 'right'], Dimension, Literal['top', 'bottom'], Dimension] | tuple[Literal['left'], Dimension, Literal['top', 'bottom'], Dimension] | tuple[Literal['left', 'right'], Dimension, Literal['top'], Dimension], Any] | None:
    ...

def parse_color_stop(tokens): # -> tuple[Color | Literal['currentcolor'] | None, None] | tuple[Color, None] | tuple[Color | Literal['currentcolor'], Dimension]:
    ...

def parse_function(function_token): # -> tuple[Any, list[Any]] | None:
    """Parse functional notation.

    Return ``(name, args)`` if the given token is a function with comma- or
    space-separated arguments. Return ``None`` otherwise.

    """
    ...

def check_attr_function(token, allowed_type=...): # -> tuple[Literal['attr()'], tuple[Any, Any | str, Any | str]] | None:
    ...

def check_counter_function(token, allowed_type=...): # -> tuple[LiteralString, tuple[Any, ...]] | None:
    ...

def check_content_function(token): # -> tuple[Literal['content()'], Literal['text']] | tuple[Literal['content()'], Literal['text', 'before', 'after', 'first-letter', 'marker']] | None:
    ...

def check_string_or_element_function(string_or_element, token): # -> tuple[str, tuple[Any, str]] | None:
    ...

def check_var_function(token): # -> Literal[True] | None:
    ...

def get_string(token): # -> tuple[Literal['string'], Any] | tuple[Literal['attr()'], tuple[Any, Any | str, Any | str]] | tuple[LiteralString, tuple[Any, ...]] | tuple[Literal['content()'], Literal['text']] | tuple[Literal['content()'], Literal['text', 'before', 'after', 'first-letter', 'marker']] | tuple[str, tuple[Any, str]] | None:
    """Parse a <string> token."""
    ...

def get_length(token, negative=..., percentage=...): # -> Dimension | None:
    """Parse a <length> token."""
    ...

def get_angle(token): # -> None:
    """Parse an <angle> token in radians."""
    ...

def get_resolution(token): # -> None:
    """Parse a <resolution> token in ddpx."""
    ...

def get_image(token, base_url): # -> tuple[Literal['url'], str | Any] | tuple[Literal['linear-gradient'], LinearGradient] | tuple[Literal['radial-gradient'], RadialGradient] | None:
    """Parse an <image> token."""
    ...

def get_url(token, base_url): # -> tuple[Literal['url'], tuple[str, str]] | tuple[Literal['url'], tuple[str, Any | str]] | tuple[Literal['attr()'], tuple[Any, Any | str, Any | str]] | None:
    """Parse an <url> token."""
    ...

def get_quote(token): # -> Literal['open-quote', 'close-quote', 'no-open-quote', 'no-close-quote'] | None:
    """Parse a <quote> token."""
    ...

def get_target(token, base_url): # -> tuple[LiteralString, tuple[Any, ...]] | None:
    """Parse a <target> token."""
    ...

def get_content_list(tokens, base_url): # -> list[tuple[Literal['string'], Any] | tuple[Literal['attr()'], tuple[Any, Any | str, Any | str]] | tuple[LiteralString, tuple[Any, ...]] | tuple[Literal['content()'], Literal['text']] | tuple[Literal['content()'], Literal['text', 'before', 'after', 'first-letter', 'marker']] | tuple[str, tuple[Any, str]] | tuple[Literal['url'], tuple[str, str]] | tuple[Literal['url'], tuple[str, Any | str]] | tuple[Literal['quote'], Literal['open-quote', 'close-quote', 'no-open-quote', 'no-close-quote']] | tuple[Literal['leader()'], tuple[str, Any | str | None]] | None] | None:
    """Parse <content-list> tokens."""
    ...

def get_content_list_token(token, base_url): # -> tuple[Literal['string'], Any] | tuple[Literal['attr()'], tuple[Any, Any | str, Any | str]] | tuple[LiteralString, tuple[Any, ...]] | tuple[Literal['content()'], Literal['text']] | tuple[Literal['content()'], Literal['text', 'before', 'after', 'first-letter', 'marker']] | tuple[str, tuple[Any, str]] | tuple[Literal['url'], tuple[str, str]] | tuple[Literal['url'], tuple[str, Any | str]] | tuple[Literal['quote'], Literal['open-quote', 'close-quote', 'no-open-quote', 'no-close-quote']] | tuple[Literal['leader()'], tuple[str, Any | str | None]] | None:
    """Parse one of the <content-list> tokens."""
    ...

