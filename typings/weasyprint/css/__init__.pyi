"""
This type stub file was generated by pyright.
"""

import cssselect2
import tinycss2
import tinycss2.ast
import tinycss2.nth
from collections import namedtuple
from itertools import groupby
from logging import DEBUG, WARNING
from .. import CSS
from ..logger import LOGGER, PROGRESS_LOGGER
from ..urls import URLFetchingError, get_url_attribute, url_join
from . import counters, media_queries
from .computed_values import COMPUTER_FUNCTIONS
from .properties import INHERITED, INITIAL_NOT_COMPUTED, INITIAL_VALUES, ZERO_PIXELS
from .validation import preprocess_declarations
from .validation.descriptors import preprocess_descriptors
from .utils import InvalidValues, Pending, check_var_function, get_url, parse_function, remove_whitespace

"""Find and apply CSS.

This module takes care of steps 3 and 4 of “CSS 2.1 processing model”: Retrieve
stylesheets associated with a document and annotate every element with a value
for every CSS property.

https://www.w3.org/TR/CSS21/intro.html#processing-model

This module does this in more than two steps. The
:func:`get_all_computed_styles` function does everything, but it is itsef based
on other functions in this module.

"""
PSEUDO_ELEMENTS = ...
PageSelectorType = ...
class StyleFor:
    """Convenience function to get the computed styles for an element."""
    def __init__(self, html, sheets, presentational_hints, target_collector) -> None:
        ...
    
    def __call__(self, element, pseudo_type=...): # -> None:
        ...
    
    def set_computed_styles(self, element, parent, root=..., pseudo_type=..., base_url=..., target_collector=...): # -> None:
        """Set the computed values of styles to ``element``.

        Take the properties left by ``apply_style_rule`` on an element or
        pseudo-element and assign computed values with respect to the cascade,
        declaration priority (ie. ``!important``) and selector specificity.

        """
        ...
    
    def add_page_declarations(self, page_type): # -> None:
        ...
    
    def get_cascaded_styles(self): # -> dict[Any, Any]:
        ...
    
    def get_computed_styles(self): # -> dict[Any, Any]:
        ...
    


def get_child_text(element): # -> LiteralString:
    """Return the text directly in the element, not descendants."""
    ...

def text_decoration(key, value, parent_value, cascaded):
    ...

def find_stylesheets(wrapper_element, device_media_type, url_fetcher, base_url, font_config, counter_style, page_rules): # -> Generator[CSS, Any, None]:
    """Yield the stylesheets in ``element_tree``.

    The output order is the same as the source order.

    """
    ...

def find_style_attributes(tree, presentational_hints=..., base_url=...):
    """Yield ``specificity, (element, declaration, base_url)`` rules.

    Rules from "style" attribute are returned with specificity
    ``(1, 0, 0)``.

    If ``presentational_hints`` is ``True``, rules from presentational hints
    are returned with specificity ``(0, 0, 0)``.

    """
    ...

def declaration_precedence(origin, importance): # -> Literal[1, 2, 3, 4, 5]:
    """Return the precedence for a declaration.

    Precedence values have no meaning unless compared to each other.

    Acceptable values for ``origin`` are the strings ``'author'``, ``'user'``
    and ``'user agent'``.

    """
    ...

def resolve_var(computed, token, parent_style, known_variables=...): # -> tuple[FunctionBlock] | list[Any] | None:
    """Return token with resolved CSS variables."""
    ...

class AnonymousStyle(dict):
    """Computed style used for anonymous boxes."""
    def __init__(self, parent_style) -> None:
        ...
    
    def copy(self): # -> AnonymousStyle:
        ...
    
    def __missing__(self, key):
        ...
    


class ComputedStyle(dict):
    """Computed style used for non-anonymous boxes."""
    def __init__(self, parent_style, cascaded, element, pseudo_type, root_style, base_url) -> None:
        ...
    
    def copy(self): # -> ComputedStyle:
        ...
    
    def __missing__(self, key): # -> list[Any] | Literal['']:
        ...
    


def computed_from_cascaded(element, cascaded, parent_style, pseudo_type=..., root_style=..., base_url=..., target_collector=...): # -> AnonymousStyle | ComputedStyle:
    """Get a dict of computed style mixed from parent and cascaded styles."""
    ...

def parse_page_selectors(rule): # -> list[Any] | None:
    """Parse a page selector rule.

    Return a list of page data if the rule is correctly parsed. Page data are a
    dict containing:

    - 'side' ('left', 'right' or None),
    - 'blank' (True or None),
    - 'first' (True or None),
    - 'index' (page number or None),
    - 'name' (page name string or None), and
    - 'specificity' (list of numbers).

    Return ``None` if something went wrong while parsing the rule.

    """
    ...

def preprocess_stylesheet(device_media_type, base_url, stylesheet_rules, url_fetcher, matcher, page_rules, font_config, counter_style, ignore_imports=...):
    """Do what can be done early on stylesheet, before being in a document."""
    ...

def get_all_computed_styles(html, user_stylesheets=..., presentational_hints=..., font_config=..., counter_style=..., page_rules=..., target_collector=..., forms=...): # -> StyleFor:
    """Compute all the computed styles of all elements in ``html`` document.

    Do everything from finding author stylesheets to parsing and applying them.

    Return a ``style_for`` function that takes an element and an optional
    pseudo-element type, and return a style dict object.

    """
    ...

