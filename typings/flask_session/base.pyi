"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
from flask import Flask, Request, Response
from flask.sessions import SessionInterface as FlaskSessionInterface, SessionMixin
from werkzeug.datastructures import CallbackDict

class ServerSideSession(CallbackDict, SessionMixin):
    """Baseclass for server-side based sessions. This can be accessed through ``flask.session``.

    .. attribute:: sid

    Session id, internally we use :func:`secrets.token_urlsafe` to generate one
    session id.

    .. attribute:: modified

    When data is changed, this is set to ``True``. Only the session dictionary
    itself is tracked; if the session contains mutable data (for example a nested
    dict) then this must be set to ``True`` manually when modifying that data. The
    session cookie will only be written to the response if this is ``True``.

    .. attribute:: accessed

    When data is read (or attempted read) or written, this is set to ``True``. Used by
    :class:`.ServerSideSessionInterface` to add a ``Vary: Cookie``
    header, which allows caching proxies to cache different pages for
    different users.

    Default is ``False``.

    .. attribute:: permanent

    This sets and reflects the ``'_permanent'`` key in the dict.

    Default is ``False``.

    """
    def __bool__(self) -> bool:
        ...
    
    def __init__(self, initial: Optional[Dict[str, Any]] = ..., sid: Optional[str] = ..., permanent: Optional[bool] = ...) -> None:
        ...
    
    def __getitem__(self, key: str) -> Any:
        ...
    
    def get(self, key: str, default: Any = ...) -> Any:
        ...
    
    def setdefault(self, key: str, default: Any = ...) -> Any:
        ...
    
    def clear(self) -> None:
        """Clear the session except for the '_permanent' key."""
        ...
    


class Serializer(ABC):
    """Baseclass for session serialization."""
    @abstractmethod
    def decode(self, serialized_data: bytes) -> dict:
        """Deserialize the session data."""
        ...
    
    @abstractmethod
    def encode(self, session: ServerSideSession) -> bytes:
        """Serialize the session data."""
        ...
    


class MsgSpecSerializer(Serializer):
    def __init__(self, app: Flask, format: str) -> None:
        ...
    
    def encode(self, session: ServerSideSession) -> bytes:
        """Serialize the session data."""
        ...
    
    def decode(self, serialized_data: bytes) -> dict:
        """Deserialize the session data."""
        ...
    


class ServerSideSessionInterface(FlaskSessionInterface, ABC):
    """Used to open a :class:`flask.sessions.ServerSideSessionInterface` instance."""
    session_class = ServerSideSession
    serializer = ...
    ttl = ...
    def __init__(self, app: Flask, key_prefix: str = ..., use_signer: bool = ..., permanent: bool = ..., sid_length: int = ..., serialization_format: str = ..., cleanup_n_requests: Optional[int] = ...) -> None:
        ...
    
    def should_set_storage(self, app: Flask, session: ServerSideSession) -> bool:
        """Used by session backends to determine if session in storage
        should be set for this session cookie for this response. If the session
        has been modified, the session is set to storage. If
        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the session is
        always set to storage. In the second case, this means refreshing the
        storage expiry even if the session has not been modified.

        .. versionadded:: 0.7.0
        """
        ...
    
    def regenerate(self, session: ServerSideSession) -> None:
        """Regenerate the session id for the given session. Can be used by calling ``flask.session_interface.regenerate()``."""
        ...
    
    def save_session(self, app: Flask, session: ServerSideSession, response: Response) -> None:
        ...
    
    def open_session(self, app: Flask, request: Request) -> ServerSideSession:
        ...
    


